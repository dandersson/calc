#!/bin/sh
usage() {
	cat <<-USAGE
	A Python shell with math functions and physical constants in the namespace.

	usage: ${0##*/} [-h] [EXPR]

	optional arguments:
	  EXPR  expression to be evaluated
	  -h    show this text

	Without arguments the Python interpreter is started.
	USAGE
	exit 1
}

while getopts "h" option; do
	case $option in
		h|\? )	usage;;
	esac
done
shift $((OPTIND-1))

PYTHON="/usr/bin/env python3"

ARGS='
# Use floating point division by default.
from __future__ import division

# Import common math functions into default namespace.
from math import *

# Enable tab completion of variables and functions.
import readline
import rlcompleter

readline.parse_and_bind("tab: complete")

# Define some common constants.
c  = 299792458           # Speed of light in a vacuum, c  [m/s]
g  = 9.82                # Gravitational acceleration, g  [m/s²]
e0 = 8.854187817620e-12  # Vacuum permittivity, ε₀        [F/m]
m0 = pi*4e-7             # Vacuum permeability, μ₀        [Vs/Am]
Z0 = sqrt(m0/e0)         # Vacuum impedance, Z₀           [Ω]
ke = 1/4/pi/e0           # Coulomb constant, kₑ           [m/F]
me = 9.10938291e-31      # Electron mass, mₑ              [kg]
mp = 1.672621777e-27     # Proton mass, mₚ                [kg]
ec = 1.602176565e-19     # Fundamental charge, e          [C]
NA = 6.02214129e23       # Avogadro constant, N_A         [mol⁻¹]

# Alias log() (the natural logarithm) to ln().
ln = log

# Modules are loaded only upon function invocation below to keep general
# startup time fast.

# Compute best fractional approximation.
def frac(num, limit=10**6):
    from fractions import Fraction
    return Fraction(num).limit_denominator(limit)

# 2-norm function for vectors. Note that it handles both an adaptive number of
# direct arguments and list/tuple input.
def norm(*args):
    import numpy.linalg as npl
    return npl.norm(args)

pass' # Do not end with a newline.

if [ $# -eq 0 ]; then
	$PYTHON -ic "$ARGS"
else
	$PYTHON -c "$ARGS; print($*)"
fi
